# 📋 온프레미스 qwen-code 개발 진행 계획서

## 🎯 프로젝트 개요

**목표**: 폐쇄망 환경에서 **최소한의 수정**으로 qwen-code를 내부 LLM과 연동하는 PoC 구현

**핵심 원칙**: 
- ⭐ **최소 수정**: 정확히 3개 파일만 터치
- ⭐ **심플함**: npm install → 환경설정 → qwen 실행
- ⭐ **완전 충족**: 내부 LLM + 웹검색 + SSL 우회 모두 구현

---

## 📅 개발 일정 계획

### 🏁 전체 일정: 3-4일 (24-32시간)

```
Day 1: 📋 문서화 완료 (4시간)
Day 2: 🔧 핵심 기능 구현 (12시간) 
Day 3: ✅ 통합 테스트 및 검증 (6시간)
Day 4: 📦 패키징 및 배포 준비 (4시간)
```

---

## 📋 Phase별 상세 실행 계획

### Phase 1: 기반 구축 (Day 1: 4시간) ✅

#### ✅ 1.1 문서화 완료 (4시간)
- [x] `docs/on-premise/` 폴더 생성 및 구조 준비
- [x] `온프레미스-qwen-code-PRD.md` 요구사항 상세 문서 작성
- [x] `개발진행계획서.md` 단계별 개발 계획 작성 (현재 진행 중)
- [ ] `설치가이드.md` 사용자 설치/설정 가이드 작성

**산출물**: 
- 완전한 요구사항 문서
- 상세한 개발 계획서
- 사용자 친화적 설치 가이드

---

### Phase 2: 핵심 기능 구현 (Day 2: 12시간) 🔧

#### 2.1 설정 파일 생성 (2시간)
**목표**: 내부 웹 URL 관리 시스템 구축

##### 작업 상세
- [ ] `internal-web-config.json` 설정 파일 스키마 설계
- [ ] 샘플 내부 URL 정의 (위키, API 문서, Confluence 등)
- [ ] JSON 검증 및 로딩 로직 구현

##### 예상 파일 구조
```json
{
  "enabled": true,
  "timeout": 10000,
  "urls": {
    "company_wiki": {
      "url": "http://wiki.company.com",
      "description": "회사 내부 위키, 개발 가이드, API 문서",
      "categories": ["documentation", "technical"]
    },
    "api_docs": {
      "url": "http://api-docs.internal.com", 
      "description": "내부 API 레퍼런스, REST API 문서, 인증 가이드",
      "categories": ["api", "reference"]
    }
  }
}
```

#### 2.2 SSL 우회 기능 구현 (2시간)
**목표**: 내부망 HTTP 통신을 위한 SSL 검증 우회

##### 작업 상세
- [ ] `packages/core/src/utils/fetch.ts` 파일 분석
- [ ] 최소한의 SSL 우회 코드 추가 (5줄 이내)
- [ ] 환경변수 기반 조건부 적용
- [ ] 기존 기능 영향도 최소화

##### 구현 방식
```typescript
// fetch.ts에 추가할 최소 코드
if (process.env.ON_PREMISE_MODE === 'true') {
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
}
```

#### 2.3 내부 웹 검색 로직 구현 (8시간)
**목표**: Google API 대신 내부 URL 기반 웹 검색 시스템

##### 2.3.1 기존 코드 분석 (2시간)
- [ ] `packages/core/src/tools/web-search.ts` 구조 파악
- [ ] 기존 Google 검색 로직 이해
- [ ] 대체 가능한 인터페이스 식별

##### 2.3.2 내부 검색 로직 설계 (2시간)
- [ ] URL 매칭 알고리즘 설계 (키워드 기반)
- [ ] 웹페이지 크롤링 로직 설계
- [ ] 텍스트 추출 및 요약 로직 설계

##### 2.3.3 핵심 기능 구현 (4시간)
```typescript
export class InternalWebSearchTool extends BaseTool {
  // 1. 설정 파일 로드
  private async loadConfig(): Promise<InternalConfig>
  
  // 2. 사용자 쿼리 → 최적 URL 선택
  private selectBestUrl(query: string): string
  
  // 3. 웹페이지 크롤링 및 텍스트 추출
  private async crawlUrl(url: string): Promise<string>
  
  // 4. 메인 검색 실행 함수
  public async execute(params: WebSearchParams): Promise<ToolResult>
}
```

**구현 우선순위**:
1. JSON 설정 파일 로더
2. 단순 키워드 매칭 알고리즘  
3. 기본 HTML 크롤링 기능
4. 텍스트 추출 및 정리

---

### Phase 3: 통합 테스트 및 검증 (Day 3: 6시간) ✅

#### 3.1 단위 테스트 (2시간)
- [ ] SSL 우회 기능 테스트
- [ ] 내부 URL 매칭 알고리즘 테스트
- [ ] 웹 크롤링 기능 테스트
- [ ] 설정 파일 로딩 테스트

#### 3.2 통합 테스트 (2시간)
- [ ] 내부 LLM 서버 연동 테스트
- [ ] 전체 웹 검색 플로우 테스트
- [ ] 에러 케이스 처리 테스트

#### 3.3 시나리오 테스트 (2시간)
```bash
# 시나리오 1: 기본 채팅
qwen "Hello"
# 기대결과: 내부 LLM에서 응답

# 시나리오 2: 웹 검색
qwen "API 문서에서 인증 방법 찾아줘"
# 기대결과: 내부 API 문서 URL 접속 → 인증 방법 추출 → 답변

# 시나리오 3: 코드 생성  
qwen "Python REST API 클라이언트 코드 작성해줘"
# 기대결과: 내부 가이드 참조하여 회사 표준에 맞는 코드 생성
```

---

### Phase 4: 패키징 및 배포 준비 (Day 4: 4시간) 📦

#### 4.1 문서 완성 (2시간)
- [ ] README 업데이트
- [ ] 설치 가이드 최종 검토
- [ ] 트러블슈팅 가이드 작성

#### 4.2 배포 준비 (2시간)
- [ ] npm 빌드 및 패키징 테스트
- [ ] 배포용 환경변수 템플릿 작성
- [ ] 사용자 교육 자료 준비

---

## 🔧 수정 대상 파일 상세

### 📁 수정할 파일 (총 3개)

#### 1. `internal-web-config.json` (신규 생성)
**위치**: 프로젝트 루트  
**목적**: 내부 웹사이트 URL 및 설명 정의  
**크기**: ~50줄 (JSON)

#### 2. `packages/core/src/utils/fetch.ts` (최소 수정)
**수정 범위**: 5줄 이내 추가  
**목적**: SSL 우회 설정  
**영향도**: 최소 (조건부 실행)

#### 3. `packages/core/src/tools/web-search.ts` (로직 교체)
**수정 범위**: 전체 대체 (~200줄)  
**목적**: 내부 URL 기반 검색  
**영향도**: 해당 기능만 (격리된 모듈)

---

## 🎯 성공 기준 및 검증 방법

### 1차 검증 (PoC 달성)
- [x] 환경변수로 내부 LLM 서버 연동 ✅
- [ ] qwen 기본 명령어 정상 동작 
- [ ] 내부 웹 검색 1회 이상 성공

### 2차 검증 (완전 기능)
- [ ] 다양한 내부 웹사이트 검색 (3개 이상)
- [ ] 복잡한 질의 응답 (코드 생성, 문서 분석)
- [ ] 안정적인 장시간 사용 (1시간 이상)

### 최종 검증 (실용성)
```bash
# 완전한 사용자 시나리오
npm install -g @qwen-code/qwen-code  # 1회 설치
export OPENAI_BASE_URL="http://internal-llm:8080/v1"  # 환경설정
qwen "내부 위키에서 React 개발 가이드라인 찾아줘"  # 실행
# → 내부 위키 접속 → React 가이드 찾기 → 답변 제공 (성공!)
```

---

## 📊 위험 관리 계획

### 기술적 위험 대응

#### 높은 위험 (즉시 대응)
| 위험 | 대응 방안 | 담당 | 기한 |
|------|-----------|------|------|
| 내부 LLM API 호환성 | OpenAI 스펙 확인, 테스트 환경 구축 | 개발자 | Day 2 |
| 기존 코드 충돌 | 최소 수정 원칙 준수, 격리된 모듈 설계 | 개발자 | Day 2 |

#### 중간 위험 (모니터링)
| 위험 | 대응 방안 | 담당 | 기한 |
|------|-----------|------|------|
| 웹 크롤링 실패 | 간단한 에러 처리, 대체 URL 제공 | 개발자 | Day 3 |
| 성능 저하 | 기본 캐싱, 타임아웃 설정 | 개발자 | Day 3 |

### 프로젝트 위험 대응

#### 일정 지연 대응
- **우선순위 조정**: 핵심 기능 (LLM 연동) 우선 완성
- **기능 축소**: 웹 검색 기능 간소화 (1개 URL만 테스트)
- **병렬 작업**: 문서화와 개발 동시 진행

#### 요구사항 변경 대응
- **모듈화 설계**: 각 기능을 독립적으로 구현
- **설정 파일 기반**: 코드 수정 없이 설정 변경 가능
- **점진적 개선**: MVP 완성 후 기능 추가

---

## 🔍 품질 관리 계획

### 코드 품질 기준
- **최소 수정 원칙**: 3개 파일만 수정
- **기존 코드 스타일**: 기존 프로젝트 컨벤션 준수
- **에러 처리**: 모든 외부 호출에 에러 처리 추가
- **로깅**: 디버깅을 위한 최소한의 로그 추가

### 테스트 커버리지
- **핵심 기능**: 100% 수동 테스트
- **에러 케이스**: 주요 실패 시나리오 테스트
- **통합 테스트**: 전체 플로우 1회 이상 성공

### 문서 품질 기준
- **사용자 친화적**: 비개발자도 설치 가능한 가이드
- **완전성**: 모든 설정 옵션 설명
- **정확성**: 실제 테스트 결과 기반 문서 작성

---

## 📈 성과 측정 지표

### 기술적 성과
- **코드 수정 최소화**: 목표 3개 파일 → 실제 수정 파일 수
- **기능 완전성**: 요구사항 충족률 (목표 100%)
- **성능 유지**: 기존 qwen 대비 응답시간 (목표 120% 이내)

### 사용자 경험 성과
- **설치 복잡도**: 필요한 설정 단계 수 (목표 3단계 이내)
- **학습 곡선**: 기존 사용법과의 차이 (목표 0%)
- **안정성**: 1시간 사용 중 오류 발생 횟수 (목표 0회)

---

## 🚀 배포 및 롤아웃 계획

### 배포 전략
1. **개발자 환경 검증** (Day 4)
2. **내부 테스트 그룹 배포** (1주 후)
3. **단계적 확산** (2주 후)

### 지원 체계
- **설치 지원**: 상세한 설치 가이드 제공
- **트러블슈팅**: 자주 발생하는 문제 해결 방법 문서화
- **피드백 수집**: 사용자 의견 수집 및 개선점 도출

---

## 📝 결론

본 개발 계획서는 **"최소한의 수정으로 최대한의 효과"**를 달성하기 위한 실행 가능한 로드맵을 제시합니다.

### 핵심 성공 요소
1. **명확한 범위**: 3개 파일만 수정하는 제약 조건
2. **단계적 접근**: 문서화 → 구현 → 검증 → 배포
3. **위험 관리**: 각 단계별 위험 요소 사전 식별 및 대응
4. **품질 보장**: 테스트와 검증을 통한 안정성 확보

### 예상 결과
- ✅ **설치 시간**: 10분 이내 (npm install + 환경설정)
- ✅ **학습 시간**: 0분 (기존 사용법 동일)
- ✅ **기능 완전성**: 내부 LLM + 웹검색 + SSL 우회 100% 구현
- ✅ **확장성**: JSON 파일로 추가 웹사이트 쉽게 추가 가능

이를 통해 폐쇄망 환경에서도 강력한 AI 코딩 어시스턴트를 활용할 수 있는 기반을 마련할 수 있습니다.

---

**문서 버전**: v1.0  
**작성일**: 2025-01-26  
**작성자**: Claude Code SuperClaude  
**검토**: 개발팀  
**승인**: 프로젝트 매니저