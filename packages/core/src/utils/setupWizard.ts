/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import http from 'node:http';
import https from 'node:https';

export interface SetupWizardConfig {
  baseUrl: string;
  apiKey: string;
  model: string;
  skipSSLVerification?: boolean;
  timeout?: number;
  scope: 'local' | 'global';
}

export interface SetupWizardOptions {
  interactive?: boolean;
  autoDetect?: boolean;
  skipValidation?: boolean;
}

export interface SetupResult {
  success: boolean;
  message: string;
  configPath?: string;
  errors?: string[];
  recommendations?: string[];
}

export interface ServerDiscoveryResult {
  url: string;
  isHealthy: boolean;
  responseTime: number;
  models?: string[];
  version?: string;
}

export class SetupWizard {
  private options: SetupWizardOptions;

  constructor(options: SetupWizardOptions = {}) {
    this.options = {
      interactive: true,
      autoDetect: true,
      skipValidation: false,
      ...options,
    };
  }

  // 자동 서버 발견
  async discoverServers(candidateUrls?: string[]): Promise<ServerDiscoveryResult[]> {
    const defaultCandidates = [
      'http://localhost:8443/api/v1',
      'http://localhost:8080/api/v1',
      'http://localhost:3000/api/v1',
      'https://localhost:8443/api/v1',
      'http://127.0.0.1:8443/api/v1',
      'http://192.168.1.100:8443/api/v1', // 일반적인 내부 IP
    ];

    const candidates = candidateUrls || defaultCandidates;
    const results: ServerDiscoveryResult[] = [];

    for (const url of candidates) {
      try {
        const result = await this.testServerConnection(url);
        results.push(result);
      } catch (error) {
        results.push({
          url,
          isHealthy: false,
          responseTime: -1,
        });
      }
    }

    return results.filter(r => r.isHealthy).sort((a, b) => a.responseTime - b.responseTime);
  }

  // 서버 연결 테스트
  private async testServerConnection(url: string): Promise<ServerDiscoveryResult> {
    const startTime = Date.now();
    const isHttps = url.startsWith('https://');
    const client = isHttps ? https : http;

    return new Promise((resolve, reject) => {
      const healthUrl = `${url.replace('/api/v1', '')}/health`;
      
      const req = client.request(healthUrl, {
        method: 'GET',
        timeout: 3000,
        ...(isHttps && {
          rejectUnauthorized: false,
        }),
      }, (res) => {
        const responseTime = Date.now() - startTime;
        let data = '';

        res.on('data', (chunk) => {
          data += chunk;
        });

        res.on('end', () => {
          try {
            const healthData = JSON.parse(data);
            resolve({
              url,
              isHealthy: res.statusCode === 200,
              responseTime,
              models: healthData.models,
              version: healthData.version,
            });
          } catch {
            resolve({
              url,
              isHealthy: res.statusCode === 200,
              responseTime,
            });
          }
        });
      });

      req.on('error', () => {
        reject(new Error(`Connection failed to ${url}`));
      });

      req.setTimeout(3000, () => {
        req.destroy();
        reject(new Error(`Timeout connecting to ${url}`));
      });

      req.end();
    });
  }

  // 대화형 설정 수집
  async collectInteractiveConfig(): Promise<Partial<SetupWizardConfig>> {
    // 실제 CLI에서는 inquirer 같은 라이브러리를 사용하겠지만
    // 여기서는 기본 구현만 제공
    const config: Partial<SetupWizardConfig> = {};

    // 자동 서버 발견 시도
    if (this.options.autoDetect) {
      console.log('🔍 Discovering internal LLM servers...');
      const discovered = await this.discoverServers();
      
      if (discovered.length > 0) {
        console.log(`✅ Found ${discovered.length} healthy server(s):`);
        discovered.forEach((server, index) => {
          console.log(`  ${index + 1}. ${server.url} (${server.responseTime}ms)`);
        });
        
        // 첫 번째 서버를 기본값으로 사용
        config.baseUrl = discovered[0].url;
      } else {
        console.log('⚠️ No healthy servers found automatically.');
      }
    }

    return config;
  }

  // 설정 템플릿 생성
  generateConfigTemplate(config: SetupWizardConfig): string {
    return `# Qwen Code Internal LLM Configuration
# Generated by Setup Wizard

# LLM Server Configuration
INTERNAL_LLM_BASE_URL=${config.baseUrl}
INTERNAL_LLM_API_KEY=${config.apiKey}
INTERNAL_LLM_MODEL=${config.model}

# Optional Settings
${config.skipSSLVerification ? 'NODE_TLS_REJECT_UNAUTHORIZED=0' : '# NODE_TLS_REJECT_UNAUTHORIZED=0'}
${config.timeout ? `INTERNAL_LLM_TIMEOUT=${config.timeout}` : '# INTERNAL_LLM_TIMEOUT=30000'}

# Debug Settings (uncomment if needed)
# DEBUG=1
# INTERNAL_LLM_VERBOSE=true

# Generated on: ${new Date().toISOString()}
`;
  }

  // 설정 파일 저장
  async saveConfig(config: SetupWizardConfig): Promise<SetupResult> {
    try {
      const configContent = this.generateConfigTemplate(config);
      let configPath: string;

      if (config.scope === 'global') {
        const homeDir = os.homedir();
        const qwenDir = path.join(homeDir, '.qwen');
        
        // .qwen 디렉토리 생성
        if (!fs.existsSync(qwenDir)) {
          fs.mkdirSync(qwenDir, { recursive: true });
        }
        
        configPath = path.join(qwenDir, '.env');
      } else {
        // 로컬 설정
        configPath = path.join(process.cwd(), '.env');
      }

      // 기존 설정 백업
      if (fs.existsSync(configPath)) {
        const backupPath = `${configPath}.backup.${Date.now()}`;
        fs.copyFileSync(configPath, backupPath);
        console.log(`📦 Existing config backed up to: ${backupPath}`);
      }

      // 새 설정 저장
      fs.writeFileSync(configPath, configContent, 'utf8');

      const recommendations = this.generateRecommendations(config);

      return {
        success: true,
        message: `Configuration saved successfully to ${configPath}`,
        configPath,
        recommendations,
      };

    } catch (error) {
      return {
        success: false,
        message: `Failed to save configuration: ${error instanceof Error ? error.message : String(error)}`,
        errors: [error instanceof Error ? error.message : String(error)],
      };
    }
  }

  // 설정 검증
  async validateConfig(config: SetupWizardConfig): Promise<SetupResult> {
    const errors: string[] = [];
    const recommendations: string[] = [];

    // 기본 유효성 검사
    if (!config.baseUrl) {
      errors.push('Base URL is required');
    } else if (!this.isValidUrl(config.baseUrl)) {
      errors.push('Invalid Base URL format');
    }

    if (!config.apiKey) {
      errors.push('API Key is required');
    }

    if (!config.model) {
      errors.push('Model name is required');
    }

    // 네트워크 연결 테스트
    if (!this.options.skipValidation && config.baseUrl) {
      try {
        const serverResult = await this.testServerConnection(config.baseUrl);
        if (!serverResult.isHealthy) {
          errors.push(`Cannot connect to server: ${config.baseUrl}`);
        } else {
          recommendations.push(`Server connection successful (${serverResult.responseTime}ms)`);
          
          if (serverResult.models && !serverResult.models.includes(config.model)) {
            recommendations.push(`Available models: ${serverResult.models.join(', ')}`);
          }
        }
      } catch (error) {
        errors.push(`Connection test failed: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    // 보안 권장사항
    if (config.skipSSLVerification) {
      recommendations.push('SSL verification is disabled. Only use this in development environments.');
    }

    if (config.baseUrl.startsWith('http://')) {
      recommendations.push('Consider using HTTPS for production environments.');
    }

    return {
      success: errors.length === 0,
      message: errors.length === 0 ? 'Configuration is valid' : 'Configuration has errors',
      errors: errors.length > 0 ? errors : undefined,
      recommendations: recommendations.length > 0 ? recommendations : undefined,
    };
  }

  // 완전 자동 설정
  async autoSetup(options: { 
    scope?: 'local' | 'global';
    defaultApiKey?: string;
    defaultModel?: string;
  } = {}): Promise<SetupResult> {
    try {
      console.log('🚀 Starting automatic setup...');

      // 서버 자동 발견
      const servers = await this.discoverServers();
      
      if (servers.length === 0) {
        return {
          success: false,
          message: 'No healthy servers found. Please configure manually.',
          recommendations: [
            'Start your internal LLM server',
            'Check if the server is running on a standard port (8443, 8080, 3000)',
            'Verify network connectivity',
            'Run manual setup with custom server URL',
          ],
        };
      }

      const bestServer = servers[0];
      console.log(`✅ Selected server: ${bestServer.url} (${bestServer.responseTime}ms)`);

      // 기본 설정 생성
      const config: SetupWizardConfig = {
        baseUrl: bestServer.url,
        apiKey: options.defaultApiKey || 'your-api-key-here',
        model: options.defaultModel || bestServer.models?.[0] || 'default-model',
        skipSSLVerification: bestServer.url.startsWith('https://') && bestServer.url.includes('localhost'),
        scope: options.scope || 'local',
      };

      // 설정 검증
      const validation = await this.validateConfig(config);
      if (!validation.success) {
        return validation;
      }

      // 설정 저장
      const saveResult = await this.saveConfig(config);
      
      if (saveResult.success) {
        console.log('🎉 Automatic setup completed successfully!');
        console.log(`📁 Configuration saved to: ${saveResult.configPath}`);
        
        if (config.apiKey === 'your-api-key-here') {
          console.log('⚠️ Please update the API key in your configuration file.');
        }
      }

      return saveResult;

    } catch (error) {
      return {
        success: false,
        message: `Auto setup failed: ${error instanceof Error ? error.message : String(error)}`,
        errors: [error instanceof Error ? error.message : String(error)],
      };
    }
  }

  // 유틸리티 메서드들
  private isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  private generateRecommendations(config: SetupWizardConfig): string[] {
    const recommendations: string[] = [];

    recommendations.push('Run `qwen /validate` to test your configuration');
    recommendations.push('Use `qwen /diagnose` for quick connection tests');
    
    if (config.scope === 'global') {
      recommendations.push('Global configuration will be used for all projects');
    } else {
      recommendations.push('Local configuration will only affect this project');
    }

    if (config.baseUrl.includes('localhost') || config.baseUrl.includes('127.0.0.1')) {
      recommendations.push('Localhost configuration detected - ensure server is running locally');
    }

    return recommendations;
  }

  // 기존 설정 감지
  async detectExistingConfig(): Promise<{
    hasLocal: boolean;
    hasGlobal: boolean;
    localPath?: string;
    globalPath?: string;
  }> {
    const localPath = path.join(process.cwd(), '.env');
    const globalPath = path.join(os.homedir(), '.qwen', '.env');

    return {
      hasLocal: fs.existsSync(localPath),
      hasGlobal: fs.existsSync(globalPath),
      localPath: fs.existsSync(localPath) ? localPath : undefined,
      globalPath: fs.existsSync(globalPath) ? globalPath : undefined,
    };
  }
}