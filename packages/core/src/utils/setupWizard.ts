/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import http from 'node:http';
import https from 'node:https';

export interface SetupWizardConfig {
  baseUrl: string;
  apiKey: string;
  model: string;
  skipSSLVerification?: boolean;
  timeout?: number;
  scope: 'local' | 'global';
}

export interface SetupWizardOptions {
  interactive?: boolean;
  autoDetect?: boolean;
  skipValidation?: boolean;
}

export interface SetupResult {
  success: boolean;
  message: string;
  configPath?: string;
  errors?: string[];
  recommendations?: string[];
}

export interface ServerDiscoveryResult {
  url: string;
  isHealthy: boolean;
  responseTime: number;
  models?: string[];
  version?: string;
}

export class SetupWizard {
  private options: SetupWizardOptions;

  constructor(options: SetupWizardOptions = {}) {
    this.options = {
      interactive: true,
      autoDetect: true,
      skipValidation: false,
      ...options,
    };
  }

  // ìë™ ì„œë²„ ë°œê²¬
  async discoverServers(candidateUrls?: string[]): Promise<ServerDiscoveryResult[]> {
    const defaultCandidates = [
      'http://localhost:8443/api/v1',
      'http://localhost:8080/api/v1',
      'http://localhost:3000/api/v1',
      'https://localhost:8443/api/v1',
      'http://127.0.0.1:8443/api/v1',
      'http://192.168.1.100:8443/api/v1', // ì¼ë°˜ì ì¸ ë‚´ë¶€ IP
    ];

    const candidates = candidateUrls || defaultCandidates;
    const results: ServerDiscoveryResult[] = [];

    for (const url of candidates) {
      try {
        const result = await this.testServerConnection(url);
        results.push(result);
      } catch (error) {
        results.push({
          url,
          isHealthy: false,
          responseTime: -1,
        });
      }
    }

    return results.filter(r => r.isHealthy).sort((a, b) => a.responseTime - b.responseTime);
  }

  // ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸
  private async testServerConnection(url: string): Promise<ServerDiscoveryResult> {
    const startTime = Date.now();
    const isHttps = url.startsWith('https://');
    const client = isHttps ? https : http;

    return new Promise((resolve, reject) => {
      const healthUrl = `${url.replace('/api/v1', '')}/health`;
      
      const req = client.request(healthUrl, {
        method: 'GET',
        timeout: 3000,
        ...(isHttps && {
          rejectUnauthorized: false,
        }),
      }, (res) => {
        const responseTime = Date.now() - startTime;
        let data = '';

        res.on('data', (chunk) => {
          data += chunk;
        });

        res.on('end', () => {
          try {
            const healthData = JSON.parse(data);
            resolve({
              url,
              isHealthy: res.statusCode === 200,
              responseTime,
              models: healthData.models,
              version: healthData.version,
            });
          } catch {
            resolve({
              url,
              isHealthy: res.statusCode === 200,
              responseTime,
            });
          }
        });
      });

      req.on('error', () => {
        reject(new Error(`Connection failed to ${url}`));
      });

      req.setTimeout(3000, () => {
        req.destroy();
        reject(new Error(`Timeout connecting to ${url}`));
      });

      req.end();
    });
  }

  // ëŒ€í™”í˜• ì„¤ì • ìˆ˜ì§‘
  async collectInteractiveConfig(): Promise<Partial<SetupWizardConfig>> {
    // ì‹¤ì œ CLIì—ì„œëŠ” inquirer ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ê² ì§€ë§Œ
    // ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ êµ¬í˜„ë§Œ ì œê³µ
    const config: Partial<SetupWizardConfig> = {};

    // ìë™ ì„œë²„ ë°œê²¬ ì‹œë„
    if (this.options.autoDetect) {
      console.log('ğŸ” Discovering internal LLM servers...');
      const discovered = await this.discoverServers();
      
      if (discovered.length > 0) {
        console.log(`âœ… Found ${discovered.length} healthy server(s):`);
        discovered.forEach((server, index) => {
          console.log(`  ${index + 1}. ${server.url} (${server.responseTime}ms)`);
        });
        
        // ì²« ë²ˆì§¸ ì„œë²„ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©
        config.baseUrl = discovered[0].url;
      } else {
        console.log('âš ï¸ No healthy servers found automatically.');
      }
    }

    return config;
  }

  // ì„¤ì • í…œí”Œë¦¿ ìƒì„±
  generateConfigTemplate(config: SetupWizardConfig): string {
    return `# Qwen Code Internal LLM Configuration
# Generated by Setup Wizard

# LLM Server Configuration
INTERNAL_LLM_BASE_URL=${config.baseUrl}
INTERNAL_LLM_API_KEY=${config.apiKey}
INTERNAL_LLM_MODEL=${config.model}

# Optional Settings
${config.skipSSLVerification ? 'NODE_TLS_REJECT_UNAUTHORIZED=0' : '# NODE_TLS_REJECT_UNAUTHORIZED=0'}
${config.timeout ? `INTERNAL_LLM_TIMEOUT=${config.timeout}` : '# INTERNAL_LLM_TIMEOUT=30000'}

# Debug Settings (uncomment if needed)
# DEBUG=1
# INTERNAL_LLM_VERBOSE=true

# Generated on: ${new Date().toISOString()}
`;
  }

  // ì„¤ì • íŒŒì¼ ì €ì¥
  async saveConfig(config: SetupWizardConfig): Promise<SetupResult> {
    try {
      const configContent = this.generateConfigTemplate(config);
      let configPath: string;

      if (config.scope === 'global') {
        const homeDir = os.homedir();
        const qwenDir = path.join(homeDir, '.qwen');
        
        // .qwen ë””ë ‰í† ë¦¬ ìƒì„±
        if (!fs.existsSync(qwenDir)) {
          fs.mkdirSync(qwenDir, { recursive: true });
        }
        
        configPath = path.join(qwenDir, '.env');
      } else {
        // ë¡œì»¬ ì„¤ì •
        configPath = path.join(process.cwd(), '.env');
      }

      // ê¸°ì¡´ ì„¤ì • ë°±ì—…
      if (fs.existsSync(configPath)) {
        const backupPath = `${configPath}.backup.${Date.now()}`;
        fs.copyFileSync(configPath, backupPath);
        console.log(`ğŸ“¦ Existing config backed up to: ${backupPath}`);
      }

      // ìƒˆ ì„¤ì • ì €ì¥
      fs.writeFileSync(configPath, configContent, 'utf8');

      const recommendations = this.generateRecommendations(config);

      return {
        success: true,
        message: `Configuration saved successfully to ${configPath}`,
        configPath,
        recommendations,
      };

    } catch (error) {
      return {
        success: false,
        message: `Failed to save configuration: ${error instanceof Error ? error.message : String(error)}`,
        errors: [error instanceof Error ? error.message : String(error)],
      };
    }
  }

  // ì„¤ì • ê²€ì¦
  async validateConfig(config: SetupWizardConfig): Promise<SetupResult> {
    const errors: string[] = [];
    const recommendations: string[] = [];

    // ê¸°ë³¸ ìœ íš¨ì„± ê²€ì‚¬
    if (!config.baseUrl) {
      errors.push('Base URL is required');
    } else if (!this.isValidUrl(config.baseUrl)) {
      errors.push('Invalid Base URL format');
    }

    if (!config.apiKey) {
      errors.push('API Key is required');
    }

    if (!config.model) {
      errors.push('Model name is required');
    }

    // ë„¤íŠ¸ì›Œí¬ ì—°ê²° í…ŒìŠ¤íŠ¸
    if (!this.options.skipValidation && config.baseUrl) {
      try {
        const serverResult = await this.testServerConnection(config.baseUrl);
        if (!serverResult.isHealthy) {
          errors.push(`Cannot connect to server: ${config.baseUrl}`);
        } else {
          recommendations.push(`Server connection successful (${serverResult.responseTime}ms)`);
          
          if (serverResult.models && !serverResult.models.includes(config.model)) {
            recommendations.push(`Available models: ${serverResult.models.join(', ')}`);
          }
        }
      } catch (error) {
        errors.push(`Connection test failed: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    // ë³´ì•ˆ ê¶Œì¥ì‚¬í•­
    if (config.skipSSLVerification) {
      recommendations.push('SSL verification is disabled. Only use this in development environments.');
    }

    if (config.baseUrl.startsWith('http://')) {
      recommendations.push('Consider using HTTPS for production environments.');
    }

    return {
      success: errors.length === 0,
      message: errors.length === 0 ? 'Configuration is valid' : 'Configuration has errors',
      errors: errors.length > 0 ? errors : undefined,
      recommendations: recommendations.length > 0 ? recommendations : undefined,
    };
  }

  // ì™„ì „ ìë™ ì„¤ì •
  async autoSetup(options: { 
    scope?: 'local' | 'global';
    defaultApiKey?: string;
    defaultModel?: string;
  } = {}): Promise<SetupResult> {
    try {
      console.log('ğŸš€ Starting automatic setup...');

      // ì„œë²„ ìë™ ë°œê²¬
      const servers = await this.discoverServers();
      
      if (servers.length === 0) {
        return {
          success: false,
          message: 'No healthy servers found. Please configure manually.',
          recommendations: [
            'Start your internal LLM server',
            'Check if the server is running on a standard port (8443, 8080, 3000)',
            'Verify network connectivity',
            'Run manual setup with custom server URL',
          ],
        };
      }

      const bestServer = servers[0];
      console.log(`âœ… Selected server: ${bestServer.url} (${bestServer.responseTime}ms)`);

      // ê¸°ë³¸ ì„¤ì • ìƒì„±
      const config: SetupWizardConfig = {
        baseUrl: bestServer.url,
        apiKey: options.defaultApiKey || 'your-api-key-here',
        model: options.defaultModel || bestServer.models?.[0] || 'default-model',
        skipSSLVerification: bestServer.url.startsWith('https://') && bestServer.url.includes('localhost'),
        scope: options.scope || 'local',
      };

      // ì„¤ì • ê²€ì¦
      const validation = await this.validateConfig(config);
      if (!validation.success) {
        return validation;
      }

      // ì„¤ì • ì €ì¥
      const saveResult = await this.saveConfig(config);
      
      if (saveResult.success) {
        console.log('ğŸ‰ Automatic setup completed successfully!');
        console.log(`ğŸ“ Configuration saved to: ${saveResult.configPath}`);
        
        if (config.apiKey === 'your-api-key-here') {
          console.log('âš ï¸ Please update the API key in your configuration file.');
        }
      }

      return saveResult;

    } catch (error) {
      return {
        success: false,
        message: `Auto setup failed: ${error instanceof Error ? error.message : String(error)}`,
        errors: [error instanceof Error ? error.message : String(error)],
      };
    }
  }

  // ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  private isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  private generateRecommendations(config: SetupWizardConfig): string[] {
    const recommendations: string[] = [];

    recommendations.push('Run `qwen /validate` to test your configuration');
    recommendations.push('Use `qwen /diagnose` for quick connection tests');
    
    if (config.scope === 'global') {
      recommendations.push('Global configuration will be used for all projects');
    } else {
      recommendations.push('Local configuration will only affect this project');
    }

    if (config.baseUrl.includes('localhost') || config.baseUrl.includes('127.0.0.1')) {
      recommendations.push('Localhost configuration detected - ensure server is running locally');
    }

    return recommendations;
  }

  // ê¸°ì¡´ ì„¤ì • ê°ì§€
  async detectExistingConfig(): Promise<{
    hasLocal: boolean;
    hasGlobal: boolean;
    localPath?: string;
    globalPath?: string;
  }> {
    const localPath = path.join(process.cwd(), '.env');
    const globalPath = path.join(os.homedir(), '.qwen', '.env');

    return {
      hasLocal: fs.existsSync(localPath),
      hasGlobal: fs.existsSync(globalPath),
      localPath: fs.existsSync(localPath) ? localPath : undefined,
      globalPath: fs.existsSync(globalPath) ? globalPath : undefined,
    };
  }
}